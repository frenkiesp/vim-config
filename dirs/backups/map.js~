function Map(options){

    //default options
    this.options = {
      id: "map", //the div id where show the map
      initLat: 0, //initial latitude
      initLong: 0, //initial longitude
      initZoom: 3, //initial map zoom 
      searchField: true, //add search function
      groupFilter: true, //add a box to filter by groups of markers
      tagFilter: true, //add a box to filter markers by tags
      searchFilters: ['groups','tags','path'], //specify an optional list of marker fields through filter markers
      exclusiveSearch: true, // show only the searched results on the map
      filterResetLabel: "Reset filters (Esc)",
      searchExitLabel: "Exit search (Esc)",
      clusterize: true,
      editorMode: false //editor mode is used to set marker location 
    }; 
    
    this.
    
    $.extend(true, this.options, options);

    this.osmTileUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    this.osmAttribution = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';

    var that = this;

    //private attributes

    //marker icon default settings
    this._baseMarkerIcon = L.Icon.extend({
        options: {
            iconSize:     [0, 0], // size of the icon
            iconAnchor:   [0, 0], // point of the icon which will correspond to marker's location
            popupAnchor:  [0, 0] // point from which the popup should open relative to the iconAnchor
        }
    });
    //common settings of the marker label
    this._commonLabelSettings= {
                  permanent: true, 
                  direction: 'right',
                  offset: L.point(0,0),
                  direction: 'bottom',
    };
    this._controlGroup = null; // MultiLevel control layer for group filter
    this._controlTag = null;// MultiLevel control layer for tag filter
    this._controlSearch = null; // Control layer for search plugin
    this._markersDict; // "Dictonary" that contains all the markers of the map, key is the marker label
    this._excludedMarkersNames = []; //list of markers excluded by search

    this._markerWithPopupOpenID = "";

    //private methods
    
    this._initialize = function(){
        this._firstMapLoad = true;
        //default geographical centre of Earth
        this.map = L.map(this.options.id, {maxZoom: 18}).setView([this.options.initLat, this.options.initLong], this.options.initZoom);

        this._markerFilterMap = new MarkerFilterMap(this);
        if(this.options.groupFilter){   
            this._markerGroupFilter = new MarkerFilter('groups');
            this._markerFilterMap.add(this._markerGroupFilter);
        }
        if(this.options.tagFilter){
            this._markerTagFilter = new MarkerFilter('tags');
            this._markerFilterMap.add(this._markerTagFilter);
        }
        this._mapSnapshot = new MapSnapshot(this);
        
        //clusterize
        if(this.options.clusterize){
            this._mcgLayerSupportGroup = L.markerClusterGroup.layerSupport({chunkedLoading: true});
            this._mcgLayerSupportGroup.addTo(this.map);
        }

        // set the tile layer
        L.tileLayer(this.osmTileUrl, {
              attribution: this.osmAttribution
        }).addTo(this.map);

        if(this.options.searchField || this.options.groupFilter || this.options.tagFilter)
            this._createResetFiltersButton();

        $(document).keydown(function(e) {
            if (e.originalEvent.keyCode == 27) { // escape key maps to keycode `27`
                 that._resetMapFiltersAndSearch();
            }
        });
    };
    
    this._resetMapFiltersAndSearch = function(){
        $(".leaflet-control-layers-toggle.groups").css("display","");
        //reset the search filter
        for(marker in that._markersDict){
           that.map.addLayer(that._markersDict[marker]); 
        }
        that._excludedMarkersNames = [];
        if(that._mapSnapshot.exists('before_search')){
            this._controlSearch.cancel();
            that._mapSnapshot.resume('before_search');
            that._mapSnapshot.delete('before_search');
        }else{
            //reset the filters (check all the checkboxes)
            var filterOptions = that._groupFilterOptions.concat(that._tagFilterOptions);
            filterOptions.forEach(function(item){
                that.map.addLayer(item.layerGroup); 
            });
            $(".leaflet-control-layers-selector").prop('checked', true);
            $(".leaflet-control-layers-selector").next().next().removeClass('hide-level');
        }
        $("#map-mode-button").html(this.options.filterResetLabel);
        that.fitBounds();
    };

    this._getAllMarkers = function(){
        var markers = [];
        for(var marker in this._markersDict){
            markers.push(this._markersDict[marker]);
        }    
        return markers;
      
    };
    
    this._getVisibleMarkers = function(){
        var bounds = [];
        this.map.eachLayer(function (layer) {
          if(layer.options.label !== undefined){
              bounds.push(layer);
          }
        });
        return bounds;
    };
    
    this._addMarker = function(marker){
        
         var markerIcon = new this._baseMarkerIcon({iconUrl: marker.iconPath, shadowUrl: marker.shadowPath});
         marker.icon = markerIcon;

         var leafletMarker = L.marker([marker.latitude, marker.longitude], marker); 
         delete leafletMarker.options.latitude;
         delete leafletMarker.options.longitude;
         delete leafletMarker.options.iconPath;
         delete leafletMarker.options.shadowPath;
       
         var label = marker.label; 
         var groups = marker.groups;
         var tags = marker.tags;
         var path = marker.path;
         var popupContentGenerator = marker.popupContentGenerator;
         //add to a layer group
         if(groups === undefined || groups.length == 0){
            //add a default group with no name
            groups = [""];
            //if a path is setted add a group with the same name of the last path level
            if(path){
                var levels = path.split("/");
                var last_level = levels[levels.length-1];
                groups = [last_level];
            }
            leafletMarker.options.groups = groups;
         }
         this._markerGroupFilter.addMarker(leafletMarker);
         if(tags !== undefined)
            this._markerTagFilter.addMarker(leafletMarker);

         if(!this.options.editorMode && (label == this._markerWithPopupOpenID)){
            this._markerWaiting = leafletMarker;
            //update current marker popup information
            var popupMarker = this._markerWithPopupOpen;
            popupContentGenerator(this._markerWithPopupOpen);
            popupMarker.options = this._markerWaiting.options;
            popupMarker.setIcon(markerIcon);
            //add the label
            that._commonLabelSettings['className']=this._markerWaiting.options.labelClassName;
            //delete popupMarker._tooltip;
            //delete this._markerWaiting._tooltip;
            popupMarker.unbindTooltip();
            popupMarker.bindTooltip(label, that._commonLabelSettings);
            this._markerWaiting.bindTooltip(label, that._commonLabelSettings);
         }
         
         if(popupContentGenerator !== undefined)
         {
            var popup = new L.popup().setContent();
            leafletMarker.bindPopup(popup);
            leafletMarker.on('popupopen', function(event){
                var marker = event.target;
                marker.options.popupContentGenerator(marker);
            });
            leafletMarker.on('popupclose', function(event){
                var marker = that._markerWaiting;
                that._markerWithPopupOpenID = "";
                if(marker){
                    that._markerGroupFilter.addMarker(event.target);
                    if(marker.options.tags !== undefined)
                        that._markerTagFilter.addMarker(event.target);
                    that._markersDict[label] = event.target;
                    that._markerWaiting = null;
                }
            });
         }

         if(label !== undefined && (this.options.editorMode || (label != this._markerWithPopupOpenID))){
            this._commonLabelSettings['className']=marker.labelClassName;
            leafletMarker.bindTooltip(label, this._commonLabelSettings);
         }

         // add the marker to markerDict
         if(this.options.editorMode || (label != this._markerWithPopupOpenID))
            this._markersDict[label] = leafletMarker; 
    
    };

    this._areMarkerFilterOptionsFiltered = function(markerFilterOptions, controlLayer){
        if(!controlLayer)
            return false;
        var filtered=true;
        // check whether marker groups\tags are filtered or not 
        if(markerFilterOptions === undefined || markerFilterOptions.length == 0 ){
            filtered=false;
        }else{
            markerFilterOptions.forEach(function(name){
               for(var key in controlLayer.checkboxStatus){
                    var checkboxStatus = controlLayer.checkboxStatus[key];
                    if(checkboxStatus.overlay != null){
                        if(checkboxStatus.overlay._name==name && (!checkboxStatus.checked || checkboxStatus.hidden)){
                            filtered = filtered && true;
                        }else if (checkboxStatus.overlay._name==name && (checkboxStatus.checked || !checkboxStatus.hidden)){
                            filtered = filtered && false;
                        }
                    }
               }
            }); 
        }

        return filtered;
    };

    this._isMarkerFiltered = function(marker){
        // filtered means that the merker is not visible on the map
        var group_filtered = this._areMarkerFilterOptionsFiltered(marker.options.groups, this._controlGroup);
        var tag_filtered = this._areMarkerFilterOptionsFiltered(marker.options.tags, this._controlTag);
        
        return group_filtered || tag_filtered;
    };

    this._createResetFiltersButton = function(){
        var containerDiv = '<div class="leaflet-bottom leaflet-right" >';
        containerDiv += '<div class="leaflet-control-zoom leaflet-bar leaflet-control" style="margin-bottom: 30px;">';
        containerDiv += '<a id="map-mode-button" class="leaflet-control-zoom" href="#" style="width:auto;height:auto;padding:4px;line-height:unset;"></a></div></div>';
        $(".leaflet-control-container").append(containerDiv);
        var defaultText = this.options.filterResetLabel;
        var button = $("#map-mode-button");
        $("#map-mode-button").html(defaultText);
        button.click(function(){
            that._resetMapFiltersAndSearch();
        });
    };
    
    this._mapFilterSearchData = function(text, records) {
        //disable group filters checkboxes
        $(".leaflet-control-layers-toggle.groups").css("display","none");
        //Change reset button label 
        $("#map-mode-button").html(that.options.searchExitLabel);
        
        if(!that._mapSnapshot.exists('before_search'))
            that._mapSnapshot.save('before_search');
        var I, icase, regSearch, frecords = {};

        text = text.replace(/[.*+?^${}()|[\]\\]/g, '');  //sanitize remove all special characters
        if(text==='')
          return [];

        I = this.options.initial ? '^' : '';  //search only initial text
        icase = !this.options.casesensitive ? 'i' : undefined;

        regSearch = new RegExp(I + text, icase);

        for(var key in records) {
          var marker = records[key].layer;
          var matched = false;
          //test the marker label
          if( regSearch.test(key) ){
              matched = true;
          }
          else{
              for(var i=0;i<that.options.searchFilters.length;i++){
                  var filteredField = marker.options[that.options.searchFilters[i]];
                  if(Object.prototype.toString.call( filteredField ) === '[object Array]'){
                      for(var j=0; j<filteredField.length && matched == false;j++){
                          if(regSearch.test(filteredField[j]))
                              matched = true;
                      }
                  }else if (typeof filteredField === 'string'){
                      if(regSearch.test(filteredField))
                          matched = true;
                  }
              }
          }
          if(matched)
              //check if marker is already filtered by group or tag filters
              if(!that._isMarkerFiltered(marker))
                  frecords[key] = records[key];
        }

        if(that.options.exclusiveSearch){
            var frecordsArray = [];
            var frecordsIds = []
            that._excludedMarkersNames = [];
            for(var key in frecords){
                frecordsArray.push(frecords[key]);
                frecordsIds.push(frecords[key].layer._leaflet_id);
            }
            for(var i=0;i<frecordsArray.length;i++){
                if(!that.map.hasLayer(frecordsArray[i].layer))
                    that.map.addLayer(frecordsArray[i].layer);
                for(var key in that._markersDict){
                    var marker = that._markersDict[key];
                    if(frecordsIds.indexOf(marker._leaflet_id) <= -1){
                        that.map.removeLayer(marker);
                        //store the name of the removed markers in the list, it will be used by filters
                        that._excludedMarkersNames.push(key);
                    }
                }
            }
            that.fitBounds();
        }
        return frecords;
    };

    //default setting of the search plugin
    this._searchFieldSettings = {
                position:'topright',		
                initial: false,
                zoom: 18,
                marker: false,
                propertyName: 'label',
                collapsed: false,
                filterData: this._mapFilterSearchData,
                buildTip: function(text, val) {
			            var tags = val.layer.options.tags;
                  var groups = val.layer.options.groups;
                  var path = val.layer.options.path;
                  if(path===undefined)
                      path="";
                  var tip = '<a href="#" class="tag-'+tags[0]+'"><b>'+text+'</b>'+path+'<br>';
                  tip+= "Groups: "+groups.join()+'</a>';
                  return tip;
                }

    };

    this._clearLayerGroupMarkers = function(layerGroup){
        var markers = layerGroup.getLayers();
        markers.forEach(function(marker){
            var remove = false;
            var popup = marker.getPopup();
            //we want to maintain the popup open
            if(!that.options.editorMode && popup){
                if(!popup.isOpen()){
                    remove = true;
                }else{
                  that._markerWithPopupOpenID = marker.options.label;
                  that._markerWithPopupOpen = marker;
                }
            }else
                remove = true;
           
            if(remove) 
                layerGroup.removeLayer(marker);
        });
    };

    this._dismissFromClusterGroup = function(layerGroup){
        // Un-stamp layerGroup.
			  delete that._mcgLayerSupportGroup._layers[L.stamp(layerGroup)];
			  delete layerGroup._mcgLayerSupportGroup;

        if (layerGroup._proxyMcgLayerSupportGroup === undefined ||
			      layerGroup._proxyMcgLayerSupportGroup !== that._mcgLayerSupportGroup) {
            return;
	    	}

        delete layerGroup._proxyMcgLayerSupportGroup;
        layerGroup.addLayer = layerGroup._originalAddLayer;
        layerGroup.removeLayer = layerGroup._originalRemoveLayer;

        var id = L.stamp(layerGroup);
        delete that._mcgLayerSupportGroup._proxyLayerGroups[id];
        delete that._mcgLayerSupportGroup._proxyLayerGroupsNeedRemoving[id];  
    };

    this._clearMarkerFilterAndControlLayer = function(markerFilter, controlLayer){
        var filterOptions = markerFilter.getOptions();
        console.log(filterOptions);
        for(var option in filterOptions){
            var filterOption = filterOptions[option];
            if(controlLayer != null)
                controlLayer.removeLayer(filterOption.layerGroup);
            if(that._mcgLayerSupportGroup)
                this._dismissFromClusterGroup(filterOption.layerGroup);
            this._clearLayerGroupMarkers(filterOption.layerGroup);
        }
        markerFilter.clear();
    };

    this._clearMap = function(){
        this._clearMarkerFilterAndControlLayer(this._markerGroupFilter, this._controlGroup);
        this._clearMarkerFilterAndControlLayer(this._markerTagFilter, this._controlTag);

        if(this._controlGroup != null){
            this._controlGroup.clearLevelTree();
        }
        
        //remove event listeners
        this.map._events.overlayadd = [];
        this.map._events.overlayremove = [];   
    };

    // public methods

     /**
     * Set common settings for labels. See leaflet options
     * url: http://leafletjs.com/reference-1.0.2.html#icon
     */ 
    this.setLabelCommonSettings = function(options){
        $.extend(true, this._commonLabelSettings, options);
    };

    /**
     * Set common settings for markers icons. See leaflet options
     * url: http://leafletjs.com/reference-1.0.2.html#icon
     */ 
    this.setMarkerCommonSettings = function(options){
        this._baseMarkerIcon = L.Icon.extend({
            options: options
        });
    };

     /**
     * Set search field settings.
     * @param search plugin options
     */ 
    this.setSearchFieldSettings = function(options){
        $.extend(true, this._searchFieldSettings, options);
    };
      
    /**
     * Set a list of markers to show on the map 
     * @ markers: a list of markers with the following options:
     *
     * label: label to show under the marker icon
     * latitude,longitude: position of the marker
     * iconPath: path to the marker icon
     * shadowPath: path to the shadow icon of the marker
     * popupContentGenerator: optional callback that set the content of !_!Apopup
     * path: an optional hierarchical position of the marker written as a path, e.g: /org1/org2/
     * groups: an optional list of groups to which the marker appertains
     * tags: an optional tag list to better identify the marker
     * labelClassName: css class name for the label
     * 
     * other options provided by Leaflet are allowed (see http://leafletjs.com/reference-1.0.2.html#marker) 
     */
    this.setMarkers = function(markers){
        if(this.map !== undefined){
            this._mapSnapshot.save('before_update')
            this._clearMap();  
        }

        this._markersDict = {};
        for(var i=0;i<markers.length;i++)
            this._addMarker(markers[i]);

        if(this.options.searchField)
            this.addSearchField(this._searchFieldSettings);

        //init group\path filter control layer
        if(this._controlGroup == null && this.options.groupFilter){
            if(this._markerGroupFilter.countOptions() > 1){
                if(this.filterAnimation){
                    var options = {classNameSuffix: 'groups', 
                      animateOnOver: true, 
                      onOverAnimation: this.filterAnimation.onOverAnimation, 
                      onLeaveAnimation: this.filterAnimation.onLeaveAnimation
                    };
                    this._controlGroup = new L.control.MultiLevelLayers(null, null, options);
                }
                else
                    this._controlGroup = new L.control.MultiLevelLayers(null, null, {classNameSuffix: 'groups'});
                this._controlGroup.addTo(this.map);
            }
        }
        
        //init tag filter control layer
        if(this._controlTag == null && this.options.tagFilter){
            if(this._markerTagFilter.countOptions() > 1){
                if(this.filterAnimation){
                    var options = {multiLevels: false,
                      classNameSuffix: 'tags',
                      animateOnOver: true,
                      onOverAnimation: this.filterAnimation.onOverAnimation,
                      onLeaveAnimation: this.filterAnimation.onLeaveAnimation
                    };
                    this._controlTag = new L.control.MultiLevelLayers(null, null, options);
                }
                else
                    this._controlTag = new L.control.MultiLevelLayers(null, null, {multiLevels: false, classNameSuffix: 'tags'});
                this._controlTag.addTo(this.map);
            }
        }
        if(this.options.groupFilter && this._controlGroup)
            this._markerGroupFilter.addToControlLayer(this._controlGroup);
        if(this.options.tagFilter && this._controlTag)
            this._markerTagFilter.addToControlLayer(this._controlTag);

        //add event listeners
        this.map.on('overlayadd', function(event){
            if(that.options.groupFilter && that.options.tagFilter){
                that._markerFilterMap.activeFilterOption(event.name);
            }
            that.fitBounds();
        }).on('overlayremove', function(event){
            if(that.options.groupFilter && that.options.tagFilter){
                that._markerFilterMap.disactiveFilterOption(event.name);
            }
            that.fitBounds();
        });

        //recover filter state
        this._mapSnapshot.resume('before_update');
        //check if the map is in search mode
        if(this._mapSnapshot.exists('before_search')){
            //disable group filters checkboxes
            $(".leaflet-control-layers-toggle.groups").css("display","none"); 
        }
    };

    /***
     * Show on the map only a single marker 
     */
    this.setSingleMarker = function(marker){
       this.setMarkers([marker]); 
    };

    /***
     * Set the map bounds in order to show all the markers 
     * @param {Layer[]} markers: an optional set of markers 
     */
    this.fitBounds = function(markers){
        if(!this._mapSnapshot.resume_started){
            if(this.options.clusterize && (!this._firstMapLoad || this._controlGroup || this._controlTag) ){
                this.map.fitBounds(this._mcgLayerSupportGroup.getBounds());
                return;
            }
            if(markers===undefined){
                markers = this._getVisibleMarkers();
            }
            if(markers.length>0){
              var featureGroup = L.featureGroup(markers);
              this.map.fitBounds(featureGroup.getBounds()); 
            }else{
              this.map.fitWorld();
            }
        }
        this._firstMapLoad = false;
    }; 

    this.addSearchField = function addSearchField(options){
        var searchLayer = new L.layerGroup(this._getAllMarkers())
        searchLayer.addTo(this.map);
        options['layer']=searchLayer;
        if(this._controlSearch!=null){
            this._controlSearch.options.layer = searchLayer;
            this._controlSearch.initialize();
        }else{
            this._controlSearch = new L.Control.Search(options);
            this.map.addControl(this._controlSearch);
        }
        

    };

    this.addFullscreenToggleButton = function(options){
        L.control.fullscreen(options).addTo(this.map);  
    };

    this.addNewWindowButton = function(options){
        L.control.newwindow(options).addTo(this.map);
    };

    this.addFilterAnimation = function(onOverCallback, onLeaveCallback){
        this.filterAnimation = {};
        this.filterAnimation.onOverAnimation = onOverCallback;
        this.filterAnimation.onLeaveAnimation = onLeaveCallback;
    };

    //initialize the class
    this._initialize();
}


function MarkerFilterMap(map){
    var _map = map;
    var _markerFilters = {};

    this.add = function(markerFilter){
        markerFilter._map = _map;
        _markerFilters[markerFilter.getFilterBy()] = markerFilter;
    };
    
    this.get = function(filterByFieldName){
        return _markerFilters[filterByFieldName];
    };
     
    this.disactiveFilterOption = function(name){
        var markerFilter = _getMarkerFilterByOptionName(name);
        var markers = markerFilter.getMarkersByOptionName(name);
        if(markers.length > 0){
            markers.forEach(function(marker){
                var anyMarkerGroupActived = _markerFilters['groups'].isAnyActivedFilterOption(marker.options.groups);
                var anyMarkerTagActived = _markerFilters['tags'].isAnyActivedFilterOption(marker.options.tags)
                if(anyMarkerGroupActived && anyMarkerTagActived && !_isMarkerExcludedBySearch(marker.options.label)){
                    //show the marker on the map
                    _map.map.addLayer(marker);
                }                
            });
        }
    }; 

    this.activeFilterOption = function(name){
        var markerFilter = _getMarkerFilterByOptionName(name);
        var markers = markerFilter.getMarkersByOptionName(name);
        if(markers.length > 0){
            markers.forEach(function(marker){
                var allMarkerGroupsDisactived = _markerFilters['groups'].areAllDisactivedFilterOptions(marker.options.groups);
                var allMarkerTagsDisactived = _markerFilters['tags'].areAllDisactivedFilterOptions(marker.options.tags);
                if(allMarkerGroupsDisactived || allMarkerTagsDisactived || _isMarkerExcludedBySearch(marker.options.label)){
                    //do not show the marker on the map
                    _map.map.removeLayer(marker);
                }
            });
        }

    }; 

    this.getMarkerFilters = function(){
        return this._markerFilters;
    }

    function _isMarkerExcludedBySearch(markerLabel){
        return _map._excludedMarkersNames.indexOf(markerLabel) > -1;
    }

    function _getMarkerFilterByOptionName(optionName){
        for(var filter in _markerFilters){
            var markerFilter = _markerFilters[filter];
            var markers = markerFilter.getMarkersByOptionName(optionName);
            if(markers.length > 0)
                return markerFilter;
        } 
        return {};
    }

}


function MarkerFilter(filterByFieldName){
    //this attribute is updated by MarkerFilterList instance
    this._map = null;
    
    var _options = {};
    var _filterBy = filterByFieldName;

    this.getFilterBy = function(){
        return _filterBy;
    };

    this.getLayerGroups = function(names){
        var result = [];
        names.forEach(function(name){
            var option = _options[name];
            if(option)
                result.push(option.layerGroup);
        });
        return result;
    };
 
    this.isAnyActivedFilterOption = function(markerGroups){
        var layerGroups = this.getLayerGroups(markerGroups);
        for(var i=0;i<layerGroups.length;i++){
            if(this._map.map.hasLayer(layerGroups[i]))
                return true;
        }
        return false;
    };

    this.areAllDisactivedFilterOptions = function(markerGroups){
        if(markerGroups.length == 0)//the marker has no groups so they cannot be disactived
            return false;
        var layerGroups = this.getLayerGroups(markerGroups);
        for(var i=0;i<layerGroups.length;i++){
            if(this._map.map.hasLayer(layerGroups[i]))
                return false;
        }
        return true;
    };

    this.addToControlLayer = function(controlLayer){
        for(var option in _options ){
            var filterOption = _options[option];
            controlLayer.addOverlay(filterOption.layerGroup, filterOption.name, filterOption.path);
        }
    };

    this.addMarker = function(marker){
        var filterOptions = marker.options[_filterBy];
        for(var i=0;i<filterOptions.length;i++){
            var filterOption = _options[filterOptions[i]];
            var layerGroup;
            if(filterOption){
                if(this._map.options.editorMode || (marker.options.label != this._map._markerWithPopupOpenID))
                    filterOption.layerGroup.addLayer(marker);
            }else{
                layerGroup = L.layerGroup();
                if(this._map.options.editorMode || (marker.options.label != this._map._markerWithPopupOpenID))
                    layerGroup.addLayer(marker);
                if(this._map.options.clusterize)
                    this._map._mcgLayerSupportGroup.checkIn(layerGroup);
                layerGroup.addTo(this._map.map);
                layerGroup._name = filterOptions[i]; 
                var path = "root";
                if(marker.options.path!==undefined)
                    path += marker.options.path;
                _options[filterOptions[i]] = {name: filterOptions[i], path: path, layerGroup: layerGroup};
            }
        }
    };

    this.getMarkersByOptionName = function(name){
        var filterOptions = _options[name];
        if(filterOptions)
            return filterOptions.layerGroup.getLayers();
        else
            return [];
    };

    this.getOptions = function(){
        return _options;
    };

    this.countOptions = function(){
        var counter = 0;
        for(option in _options)
            counter++;
        return counter;
    };

    this.clear = function(){
        _options = {};
    };

}


function MapSnapshot(map){

    var _map = map;
    var _leafletMap = map.map;
    var _snapshots = {};

    this.resume_started = false;

    this.save = function(snapshotName){
        _snapshots[snapshotName] = {};
        var mapSnapshot = _snapshots[snapshotName];
        mapSnapshot.removedMarkers = [];
        mapSnapshot.removedOverlays = [];
        mapSnapshot.uncheckedInputs = [];
        
        if(_map._controlGroup!=null){
            for(var key in _map._controlGroup.checkboxStatus){
                var checkboxStatus = _map._controlGroup.checkboxStatus[key];
                if(!checkboxStatus.checked || checkboxStatus.hidden){
                    if(!checkboxStatus.checked)
                        mapSnapshot.uncheckedInputs.push(key);
                    if(checkboxStatus.overlay != null)
                        mapSnapshot.removedOverlays.push(checkboxStatus.overlay);
                }
            }
        }
        

        if(_map._controlTag!=null){
            for(var key in _map._controlTag.checkboxStatus){
                var checkboxStatus = _map._controlTag.checkboxStatus[key];
                if(!checkboxStatus.checked){
                    mapSnapshot.uncheckedInputs.push(key);
                    if(checkboxStatus.overlay != null)
                        mapSnapshot.removedOverlays.push(checkboxStatus.overlay);
                }
            }
        }
       

        //Fill removed markers
        for(key in _map._markersDict){
            var marker = _map._markersDict[key];
            if(!_leafletMap.hasLayer(marker)){
                mapSnapshot.removedMarkers.push(marker);
            }
        }

    };

    this.resume = function(snapshotName){
        this.resume_started = true;
        if(this.exists(snapshotName)){ 
            var mapSnapshot = _snapshots[snapshotName];

            // resume the last overlays and filters status 
            var markerFilters = _map._markerFilterMap.getMarkerFilters();
            mapSnapshot.removedOverlays.forEach(function(overlay){
                for (filter in markerFilters){
                    var filterOptions = markerFilters[filter].getOptions();
                    for(option in filterOptions){
                        if(option == overlay._name)
                            _leafletMap.removeLayer(filterOptions[option].layerGroup);
                    }
                }
            });
            mapSnapshot.uncheckedInputs.forEach(function(input_id){
                $("#"+input_id).prop('checked', false);
                //check if there is an accordion div
                $("#"+input_id).next().next().addClass('hide-level');
                //resume controlLayer checkbox status 
                if(_map._controlGroup!=null){
                   var checkboxStatus = _map._controlGroup.checkboxStatus[input_id];
                   if(checkboxStatus)
                      checkboxStatus.checked = false;
                }
                if(_map._controlTag!=null){
                   var checkboxStatus = _map._controlTag.checkboxStatus[input_id];
                   if(checkboxStatus)
                      checkboxStatus.checked = false;
                }
            });

            // resume the visible markers
            mapSnapshot.removedMarkers.forEach(function(marker){
                _leafletMap.removeLayer(marker);
            });
        }
      this.resume_started = false;

    };

    this.exists = function(snapshotName){
        var result = false;
        if(_snapshots[snapshotName] !== undefined)
          result = true;
        return result;
    };

    this.delete = function(snapshotName){
        delete _snapshots[snapshotName]; 
    };

}


